# Generated by Django 4.1.7 on 2023-10-08 14:01
from __future__ import unicode_literals
from django.db import migrations

import os

from django.core.serializers import base, python
from django.core.management import call_command
from django.db import migrations
from django.forms.models import model_to_dict

import logging

logger = logging.getLogger(__name__)

def move_data(apps, schema_editor):
    """
    Monkey patches get_model to ensure that you are using historically appropriate version of models when calling loaddata, etc
    """
    # SETUP
    # Save the old _get_model() function
    old_get_model = python._get_model

    # Define new _get_model() function here, which utilizes the apps argument to
    # get the historical version of a model. This piece of code is directly stolen
    # from django.core.serializers.python._get_model, unchanged. However, here it
    # has a different context, specifically, the apps variable.
    def _get_model(model_identifier):
        try:
            return apps.get_model(model_identifier)
        except (LookupError, TypeError):
            raise base.DeserializationError(
                "Invalid model identifier: '%s'" % model_identifier
            )

    # Replace the _get_model() function on the module, so loaddata can utilize it.
    python._get_model = _get_model

    # ACTION:
    importerNeighborhood = apps.get_model(app_label='importer', model_name='Neighborhood')
    importerBlob = apps.get_model(app_label='importer', model_name='Blob')

    exporterBook = apps.get_model(app_label='ebook_exporter', model_name='Book')
    exporterChapter = apps.get_model(app_label='ebook_exporter', model_name='Chapter')
    exporterSection = apps.get_model(app_label='ebook_exporter', model_name='Section')
    exporterSubsection = apps.get_model(app_label='ebook_exporter', model_name='Subsection')

    book = exporterBook.objects.first()
    for n in importerNeighborhood.objects.all():
        min_playOrder = 2
        chapter = exporterChapter.objects.create(book=book, title=n.title, playOrder=min_playOrder+n.order)
        
        #looks like flo had blobs that are a chapter description
        intro_blob = importerBlob.objects.filter(neighborhood=n, category=None, category__title="Kapitelbeschreibung").first()
        if intro_blob:
             chapter.intro = intro_blob.main_text

        chapter.save() # to make src


    for b in importerBlob.objects.filter(priority__gt=1, neighborhood__isnull=False):
        # most of the time blog sections are accessed by category: category__section
        # so if we make a new section from each old section,
        # we just need to get each blob's category.section, and give it that section directly. 
        old_section = b.category.section if b.category else b.section
        # Impressum has no old_section. that's it.
        if old_section:
            # why do some blobs have no neighborhood? where do they go?
            neighborhood = b.neighborhood

            chapter = exporterChapter.objects.get(title=neighborhood.title)
            new_section, __ = exporterSection.objects.get_or_create(title=old_section.title, order=old_section.order, chapter=chapter)
            
            subsection_attrs = ["title", "order", "priority", "category_text", "main_text", "footer_text"]
            model_dict = model_to_dict(b, fields=subsection_attrs)
            model_dict["section"] = new_section
            exporterSubsection.objects.create(**model_dict)


    # TEARDOWN: 
    # Restore old _get_model() function
    python._get_model = old_get_model


class Migration(migrations.Migration):

    dependencies = [
        (
            "ebook_exporter",
            "0002_section_remove_chapter_publish_chapter_intro_and_more",
        ),
    ]

    operations = [
        migrations.RunPython(move_data, reverse_code=migrations.RunPython.noop)
    ]
